OK — tu veux passer ton rôle en mode “converge” (on remplace le repo quoi qu’il arrive) + installer/mettre à jour bp2iutils depuis bp2itools + exécuter recup_config.sh + utiliser jq pour valider les JSON.
Je te donne tous les fichiers à remplacer (dans ton rôle existant).
Hypothèse : rôle = roles/satellite_check_bp2itools_repo/
1) defaults/main.yml (corrigé + nouveaux paramètres)
Copy code
Yaml
---
bp2itools_repo_path: "/etc/yum.repos.d/bp2itools.repo"

# Détection CPE via hostname -d (domain)
bp2itools_cpe_suffix: "cpe.intra"

# Paramètres communs repo
bp2itools_repo_id: "bp2itools"
bp2itools_repo_enabled: 1
bp2itools_repo_gpgcheck: 0
bp2itools_repo_gpgkey: ""
bp2itools_repo_sslverify: true

bp2itools_repo_exclude: ""
bp2itools_repo_priority: ""
bp2itools_repo_proxy: ""

bp2itools_repo_owner: "root"
bp2itools_repo_group: "root"
bp2itools_repo_mode: "0644"

# Profil STANDARD (non CPE)
bp2itools_standard:
  name: "bp2i"
  baseurls:
    - "http://kickstart-prod.fr.net.intra:8000/bp2itools/RHEL$releasever/"
    - "http://kickstart-back.fr.net.intra:8000/bp2itools/RHEL$releasever/"

# Profil CPE
bp2itools_cpe:
  name: "bp2i"
  baseurls:
    - "https://yum.cpe.intra/bp2itools/EL$releasever/$basearch/"

# Package
bp2itools_pkg_name: "bp2iutils"
bp2itools_pkg_enablerepo: "bp2itools"

# Script facts
bp2itools_recup_script: "/apps/sys/admin/facts/recup_config.sh"

# JSON conformité
bp2itools_json_check_enabled: true
bp2itools_json_paths:
  - "/apps/sys/admin/facts/result"   # adapte si besoin

# Debug
bp2itools_debug: false
2) templates/bp2itools.repo.j2 (inchangé mais complet)
Copy code
Ini
[{{ bp2itools_repo_id }}]
name={{ bp2itools_repo_name }}
baseurl={{ bp2itools_repo_baseurls | join(' ') }}
enabled={{ bp2itools_repo_enabled }}
gpgcheck={{ bp2itools_repo_gpgcheck }}

{% if (bp2itools_repo_gpgcheck | int) == 1 and (bp2itools_repo_gpgkey | default('') | trim) != '' -%}
gpgkey={{ bp2itools_repo_gpgkey }}
{% endif -%}

{% if (bp2itools_repo_exclude | default('') | trim) != '' -%}
exclude={{ bp2itools_repo_exclude }}
{% endif -%}

{% if (bp2itools_repo_priority | default('') | string | trim) != '' -%}
priority={{ bp2itools_repo_priority }}
{% endif -%}

{% if (bp2itools_repo_proxy | default('') | trim) != '' -%}
proxy={{ bp2itools_repo_proxy }}
{% endif -%}

sslverify={{ 1 if (bp2itools_repo_sslverify | bool) else 0 }}
3) handlers/main.yml (corrigé + makecache)
Tu avais “clean metadata”. Là on ajoute makecache derrière.
Copy code
Yaml
---
- name: Clean yum/dnf metadata and rebuild cache
  ansible.builtin.command: "{{ item }}"
  changed_when: false
  loop:
    - "dnf -q clean metadata"
    - "yum -q clean metadata"
    - "dnf -q makecache"
    - "yum -q makecache"
  failed_when: false
4) tasks/main.yml (NOUVEAU : overwrite repo + install/update pkg + recup_config + jq)
Copy code
Yaml
---
# 1) Facts minimaux (hostname/domain + pkg_mgr)
- name: Ensure minimal facts are available
  ansible.builtin.setup:
    gather_subset:
      - "!all"
      - "min"
  when: ansible_facts is not defined or ansible_facts.domain is not defined

# 2) Déterminer si machine CPE via domain (hostname -d)
- name: Compute hostname/domain and CPE flag
  ansible.builtin.set_fact:
    bp2i_hostname: "{{ ansible_facts.hostname | default(inventory_hostname) | lower }}"
    bp2i_domain: "{{ ansible_facts.domain | default('') | lower }}"
    bp2i_is_cpe: "{{ (ansible_facts.domain | default('') | lower) == (bp2itools_cpe_suffix | lower) }}"

# 3) Sélection repo (CPE vs standard)
- name: Select repo profile (CPE vs standard)
  ansible.builtin.set_fact:
    bp2itools_repo_name: "{{ (bp2i_is_cpe | bool) | ternary(bp2itools_cpe.name, bp2itools_standard.name) }}"
    bp2itools_repo_baseurls: "{{ (bp2i_is_cpe | bool) | ternary(bp2itools_cpe.baseurls, bp2itools_standard.baseurls) }}"

- name: Debug selection
  ansible.builtin.debug:
    msg:
      - "hostname={{ bp2i_hostname }}"
      - "domain={{ bp2i_domain }}"
      - "is_cpe={{ bp2i_is_cpe }}"
      - "repo_name={{ bp2itools_repo_name }}"
      - "baseurls={{ bp2itools_repo_baseurls }}"
  when: bp2itools_debug | bool

# 4) Converge: on REPLACE le repo quoi qu'il arrive
- name: Ensure bp2itools.repo is present and compliant (overwrite always)
  ansible.builtin.template:
    src: "bp2itools.repo.j2"
    dest: "{{ bp2itools_repo_path }}"
    owner: "{{ bp2itools_repo_owner }}"
    group: "{{ bp2itools_repo_group }}"
    mode: "{{ bp2itools_repo_mode }}"
  notify: Clean yum/dnf metadata and rebuild cache

# 5) Déterminer pkg_mgr (yum/dnf)
- name: Set package manager command
  ansible.builtin.set_fact:
    bp2i_pkg_mgr: "{{ 'dnf' if (ansible_pkg_mgr | default('yum')) == 'dnf' else 'yum' }}"

# 6) Vérifier si le package est installé
- name: Check if bp2iutils is installed
  ansible.builtin.command: "rpm -q {{ bp2itools_pkg_name }}"
  register: bp2iutils_rpmq
  changed_when: false
  failed_when: false

# 7) Installer si absent, sinon update (enablerepo=bp2itools)
- name: Install bp2iutils if missing
  ansible.builtin.command: >-
    {{ bp2i_pkg_mgr }} -y install {{ bp2itools_pkg_name }}
    --enablerepo={{ bp2itools_pkg_enablerepo }}
  when: bp2iutils_rpmq.rc != 0

- name: Update bp2iutils if installed
  ansible.builtin.command: >-
    {{ bp2i_pkg_mgr }} -y update {{ bp2itools_pkg_name }}
    --enablerepo={{ bp2itools_pkg_enablerepo }}
  when: bp2iutils_rpmq.rc == 0

# 8) Exécuter le script recup_config.sh (silencieux, mais on vérifie qu'il existe)
- name: Check recup_config.sh exists
  ansible.builtin.stat:
    path: "{{ bp2itools_recup_script }}"
  register: bp2i_recup_stat

- name: Run recup_config.sh (silent)
  ansible.builtin.shell: "{{ bp2itools_recup_script }} >/dev/null 2>&1"
  args:
    executable: /bin/bash
  when: bp2i_recup_stat.stat.exists
  changed_when: false

# 9) Installer jq si nécessaire (pour valider JSON)
- name: Ensure jq is installed
  ansible.builtin.package:
    name: jq
    state: present

# 10) Vérifier conformité JSON via jq (parse)
# -> On valide tous les *.json dans les répertoires indiqués
- name: Find JSON files to validate
  ansible.builtin.find:
    paths: "{{ bp2itools_json_paths }}"
    patterns: "*.json"
    file_type: file
  register: bp2i_json_find
  when: bp2itools_json_check_enabled | bool

- name: Validate JSON files with jq
  ansible.builtin.command: "jq . {{ item.path }}"
  loop: "{{ bp2i_json_find.files | default([]) }}"
  register: bp2i_jq_validate
  changed_when: false
  when: bp2itools_json_check_enabled | bool
Points clés
✅ Le repo est toujours remplacé (même s’il existe et non vide) → “converge”.
✅ yum install ... --enablerepo=bp2itools si absent, sinon yum update ...
✅ Exécution de /apps/sys/admin/facts/recup_config.sh >/dev/null 2>&1
✅ jq installé puis validation jq . file.json sur tous les JSON trouvés
Si tu veux strict “KO si JSON invalide”
Là, si jq échoue sur un fichier, la task échoue et donc le job AAP aussi ✅
Si tu veux plutôt “warning only”, je te fais la variante avec failed_when: false + rapport.
Si tu veux, dis-moi aussi dans quel répertoire exact sont tes JSON (et s’il faut exclure certains fichiers), je t’ajuste bp2itools_json_paths / patterns.